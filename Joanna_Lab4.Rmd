---
title: "Joanna_Lab4"
author: "Joanna Wright"
date: "5/20/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(here)
library(dplyr)
```

# Writing a summary function:
Write a function that takes a given data frame as its first argument, a column to summarize as its second argument, and any set of other columns to summary operations by as the third argument. (pass the dots and after, a funs argument that defaults to a list of the functions its going to apply)

## Function behavior:
By default, the function should report:  
* Total number of observations  
* Number of non-missing observations  
* Number of missing observations  
* Mean  
* Standard deviation  
* Minimum  
* Maximum  

However, the function should be flexible so it can take any function(s) as its input to summarize by, provided the function results in a single value (e.g., anything you could feed to dplyr::summarize). You’ll need an additional optional argument (should be the last argument in your function) that lists the function(s) to use in the summary. Hint: You’ll want to have this argument pre-populated with default functions.


```{r}

listof_fun <- list(
  n = function(x) length(x),
  n_valid = function(x) sum(!is.na(x)),
  mean = function(x) mean(x),
  sd = function(x) sd(x),
  min = function(x) min(x),
  max = function(x) max(x)
)


smry_function <- function(df, outcome, ..., .fun = list(n = function(x) length(x),
                                             n_valid = function(x) sum(!is.na(x)),
                                             mean = function(x) mean(x),
                                             sd = function(x) sd(x),
                                             min = function(x) min(x),
                                             max = function(x) max(x))) {
  df %>% 
    group_by(...) %>% 
    summarise_at(vars({{outcome}}), .funs = .fun)
}

smry_function(gss_cat, tvhours, marital, race, rincome, relig, .fun = list(mean, median))
gss_cat

```

### Errors:  
Embed an error if:  
Anything other than a data frame is supplied as the first argument.  
The provided column to summarize is not numeric. 

```{r}

tmp_fun <- function(df, outcome, ..., .fun = list(n = function(x) length(x),
                                             n_valid = function(x) sum(!is.na(x)),
                                             mean = function(x) mean(x),
                                             sd = function(x) sd(x),
                                             min = function(x) min(x),
                                             max = function(x) max(x))) {
            if(is.data.frame(df) == FALSE) { 
            stop("Object is not a data frame")
            } 
            if(is.numeric(outcome) == FALSE) { 
            stop("Outcome is not numeric")
            } 
  df %>% 
    group_by(...) %>% 
    summarise_at(vars({{outcome}}), .funs = .fun)
}

# but something not working here

```


### Warnings:  
Embed a warning if:  
Any of the grouping variable(s) are numeric (generally you would expect the grouping variable to be a categorical variable)  

```{r}

tmp_fun2 <- function(df, outcome, ..., .fun = list(n = function(x) length(x),
                                             n_valid = function(x) sum(!is.na(x)),
                                             mean = function(x) mean(x),
                                             sd = function(x) sd(x),
                                             min = function(x) min(x),
                                             max = function(x) max(x))) {
            if(is.data.frame(df) == FALSE) { 
            stop("Object is not a data frame")
            } 
            if(is.numeric(outcome) == FALSE) { 
            stop("Outcome is not numeric")
            } 
            if(is.numeric(...) == TRUE) { 
            warning("Grouping variables are not categorical")
            } 
  df %>% 
    group_by(...) %>% 
    summarise_at(vars({{outcome}}), .funs = .fun)
}

# if(condition1 && condition2) { expression } # AND 
# if(condition1 || condition2) { expression } # OR 


```


### Some guidance:  
If you want to use {dplyr} you’ll need to use non-standard evaluation (NSE), so either something like !!enquo(group_var), where group_var is the formal argument of your function, or {{group_var}}. Also, dplyr::pull (together with NSE) will likely be helpful for checking types for warnings/errors.

Alternatively, you might consider spliting the dataset by the grouping variable, then looping over each split to apply the function(s) supplied.


```{r}

# create a list of functions 
# listof_fun <- function(x) {
#   n <- length(x)
#   z <- na.omit(x)
#   n_valid <- length(z)
#   mean <- mean(z)
#   sd <- sd(z)
#   min <- min(z)
#   max <- max(z) 
#   return(as.tibble(c(n = n, 
#                      n_valid =n_valid, 
#                      mean=mean,
#                      sd=sd,
#                      min=min,
#                      max=max)))
# }

# does this list work using summarise_at()?: 
tmp <- iris %>% 
  summarise_at(vars(Sepal.Length), .funs = listof_fun)

# now need to wrap it in a function: 
smy_fun <- function(data, outcome) {
  data %>%
    summarise_at(vars(outcome), funs(listof_fun))
} 

# test
tmp1 <- smy_fun(iris, "Sepal.Width")
# this acheives the same result as line 51! (tmp and tmp1 are the same, which is what we want.)

# add argument for columns to group by: 
smy_fun1 <- function(data, outcome, grp) {
  data %>%
    group_by({{grp}}) %>%
    summarise_at(vars({{outcome}}), funs(listof_fun))
} 
#test: 
smy_fun1(iris, "Sepal.Width", iris$Species)

# need to unnest to see the actual data
smy_fun2 <- function(data, outcome, grp) {
  data %>%
    group_by({{grp}}) %>%
    summarise_at(vars({{outcome}}), funs(listof_fun)) %>%
    unnest(-1)
} 
#test: 
smy_fun2(iris, "Sepal.Width", iris$Species)
# it runs. and is more or less working. but we need to know which one is which for the mean, sd, min, max, etc. Why is that not here? Do we need to pivot farther up in the code? I think the problem might be at the beginning with return() on line 42... 

# going to keep building out the function anyways, but need to resolve that problem. 

# next step: one of our arguments is supposed to be the functions. so...  But we want it to default to our original list, so I'll leave that as is. Below, functs should be optional, so if it's blank, it defaults. so it should look the same as smy_fun2 above. 

smy_fun3 <- function(data, outcome, grp, functs) {
  data %>%
    group_by({{grp}}) %>%
    summarise_at(vars({{outcome}}), funs(listof_fun)) %>%
    unnest(-1)
} 

smy_fun3(iris, "Sepal.Width", iris$Species, )
# yep! it's the same. 



